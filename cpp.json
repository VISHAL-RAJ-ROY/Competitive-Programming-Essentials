{
  // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // "Print to console": {
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  // "Pretty Print Variables template": {
  //   "prefix": "print",
  //   "body": [
  //     "template < typename F, typename S >",
  //     "ostream& operator << ( ostream& os, const pair< F, S > & p ) {",
  //     "\treturn os << \"(\" << p.first << \", \" << p.second << \")\";",
  //     "}",
  //     "",
  //     "template < typename T >",
  //     "ostream &operator << ( ostream & os, const vector< T > &v ) {",
  //     "\tos << \"{\";",
  //     "\ttypename vector< T > :: const_iterator it;",
  //     "\tfor( it = v.begin(); it != v.end(); it++ ) {",
  //     "\t\tif( it != v.begin() ) os << \", \";",
  //     "\t\tos << *it;",
  //     "\t}",
  //     "\treturn os << \"}\";",
  //     "}",
  //     "",
  //     "template < typename T >",
  //     "ostream &operator << ( ostream & os, const set< T > &v ) {",
  //     "\tos << \"[\";",
  //     "\ttypename set< T > :: const_iterator it;",
  //     "\tfor ( it = v.begin(); it != v.end(); it++ ) {",
  //     "\t\tif( it != v.begin() ) os << \", \";",
  //     "\t\tos << *it;",
  //     "\t}",
  //     "\treturn os << \"]\";",
  //     "}",
  //     "",
  //     "template < typename F, typename S >",
  //     "ostream &operator << ( ostream & os, const map< F, S > &v ) {",
  //     "\tos << \"[\";",
  //     "\ttypename map< F , S >::const_iterator it;",
  //     "\tfor( it = v.begin(); it != v.end(); it++ ) {",
  //     "\t\tif( it != v.begin() ) os << \", \";",
  //     "\t\tos << it -> first << \" = \" << it -> second ;",
  //     "\t}",
  //     "\treturn os << \"]\";",
  //     "}",
  //     "",
  //     "#define print(x) cout << #x << \" = \" << x << \\"\\n\";"
  //   ],
  //   "description": "Type print(x) to Pretty Print the value of 'x'"
  // },
  "Floyd Warshall" : {
    "prefix": "floyd warshall",
    "body": [
      "void apsp( vvi & AdjMat, int V ) {",
        "\tfor (int k = 0; k < V; k++) // remember that loop order is k->i->j",
          "\t\tfor (int i = 0; i < V; i++)",
            "\t\t\tfor (int j = 0; j < V; j++)",
              "\t\t\t\tAdjMat[i][j] = min(AdjMat[i][j], AdjMat[i][k] + AdjMat[k][j]);",
      "}"
    ],
    "description": "All-Pairs Shortest Paths by Floyd Warshall DP solution"
  },
  "If statement" : {
    "prefix": "iif",
    "body": [
      "if( $1 ) {",
        "\t$2",
      "} $3"
    ],
    "description": "if statement"
  },
  "while statement" : {
    "prefix": "whi",
    "body": [
      "while( $1 ) {",
        "\t$2",
      "} $3"
    ],
    "description": "while statement"
  },
  "Equality for strings" : {
    "prefix": "equals",
    "body": [
      "bool equals( st & A, st & B ) {",
        "\tint n = len(A), m = len(B);" ,
        "\tif( n == m ) {",
            "\t\tFOR(i,0,n) {",
                "\t\t\tif( A[i] != B[i] ) return false;",
            "\t\t} return true;",
        "\t} return false;",
      "}"
    ],
    "description": "Equality for strings"
  },
  "Class for Topcoder Questions" : {
    "prefix": "class",
    "body": [
      "class $1 {",
        "\tpublic : ",
        "\t\t$2 $3($4) {",
        "\t\t\t$5",
        "\t\t}",
      "};"
    ],
    "description": "Class for topcoder questions"
  },
  "Binary Exponentiation" : {
    "prefix": "power",
    "body": [
        "int binpow(int a, int b) {",
          "\tint res = 1;",
          "\twhile (b > 0) {",
              "\t\tif (b & 1)",
                  "\t\t\tres = res * a ;",
              "\t\ta = a * a;",
              "\t\tb >>= 1;",
          "\t}",
          "\treturn res;",
        "}"
    ],
    "description": "Calculate power in O(logN)"
  },
  "Binary Exponentiation Modulo a number" : {
    "prefix": "power",
    "body": [
        "li binpow(li a, li b, li m) {",
          "\ta %= m;",
          "\tli res = 1;",
          "\twhile (b > 0) {",
              "\t\tif (b & 1)",
                  "\t\t\tres = res * a % m;",
              "\t\ta = a * a % m;",
              "\t\tb >>= 1;",
          "\t}",
          "\treturn res;",
        "}"
    ],
    "description": "Calculate power modulo a number in O(logN)"
  },
  "Sieve to generate minimum prime divisor array" : {
    "prefix": "sieve",
    "body" : [
      "const int NN = 1e6+4;",
      "int lp[NN+1];",
      "vi pr; // lp -> Least Prime Divisor Array,  pr -> List of all primes till N",
      "",
      "void genLeastPrimeDivisorArray() {",
        "\tfor (int i=2; i<=NN; ++i) {",
            "\t\tif (lp[i] == 0) {",
                "\t\t\tlp[i] = i;",
                "\t\t\tpr.push_back (i);",
            "\t\t}",
            "\t\tint x;",
            "\t\tfor (int j=0; j<(int)pr.size() && pr[j]<=lp[i] && (x=i*pr[j])<=NN; ++j)",
                "\t\t\tlp[x] = pr[j];",
        "\t}",
      "}"
    ],
    "description": "Generate Least Prime Divisor Array"
  },
  "Segment Tree With Point Update and Range Query" : {
    "prefix": "segtree",
    "body": [
        "vi v;",
        "class segtree { // left and right inclusive",
          "\tprivate:",
              "\t\tvi tree; int n;",
          "\tpublic:",
              "\t\tsegtree() {};",
              "\t\tsegtree( int N ) { n = N; tree.assign(4*n+4,0); build(1,0,n-1); }",
              "\t\tinline int func( int a, int b ) { return a+b; } // any associative function",
              "\t\tvoid build( int node, int l, int r ) {",
                  "\t\t\tif( l == r ) tree[node] = v[l];",
                  "\t\t\telse { int m = (l+r)/2, le = (node<<1), ri = le+1; build(le,l,m); build(ri,m+1,r); tree[node] = func(tree[le],tree[ri]); }",
              "\t\t}",
              "\t\tint query( int node, int l, int r, int ql, int qr ) {",
                  "\t\t\tif( ql > qr ) return 0;",
                  "\t\t\telse if( l == ql && r == qr ) return tree[node];",
                 "\t\t\telse { int m = (l+r)/2, le = (node<<1), ri = le+1; return func(query(le,l,m,ql,min(qr,m)),query(ri,m+1,r,max(m+1,ql),qr)); }",
              "\t\t}",
              "\t\tvoid update( int node, int l, int r, int index, int inc_by ) {",
                  "\t\t\tif( l == r ) tree[node] += inc_by;",
                  "\t\t\telse { int m = (l+r)/2, le = (node<<1), ri = le+1; ( m<index ? update(ri,m+1,r,index,inc_by):update(le,l,m,index,inc_by)); tree[node] = func(tree[le],tree[ri]); }",
              "\t\t}",
              "\t\tint query(int l, int r) { return query(1,0,n-1,l,r); }", 
              "\t\tvoid update(int index, int inc_by) { update(1,0,n-1,index,inc_by); }",
      "};"
    ],
    "description": "SegTree with Point Update and Range Query"
  },
  "Lazy Segment Tree" : {
    "prefix": "segtree",
    "body": [
        "vi v;",
        "class segtree_lazy { // left and right inclusive",
          "\tprivate:",
              "\t\tvi tree, lazy; int n;",
          "\tpublic:",
              "\t\tsegtree_lazy() {};",
              "\t\tsegtree_lazy( int N ) { n = N; tree.assign(4*n+4,0); lazy.assign(4*n+4,0); build(1,0,n-1); }",
              "\t\tinline int func( int a, int b ) { return a+b; } // any associative function",
              "\t\tinline void upd_lazy( int node, int l, int r, int val ) { tree[node] += (r-l+1)*val; lazy[node] += val; }",
              "\t\tinline void shift( int node, int l, int r ) { // shift may or may not require l and r depending on the query function",
                  "\t\t\tint m = (l+r)/2, val = lazy[node], le = (node<<1), ri = le+1;",
                  "\t\t\tupd_lazy(le,l,m,val); upd_lazy(ri,m+1,r,val);", 
                  "\t\t\tlazy[node] = 0;",
              "\t\t}",
              "\t\tvoid build( int node, int l, int r ) {",
                  "\t\t\tif( l == r ) tree[node] = v[l];",
                  "\t\t\telse { int m = (l+r)/2, le = (node<<1), ri = le+1; build(le,l,m); build(ri,m+1,r); tree[node] = func(tree[le],tree[ri]); }",
              "\t\t}",
              "\t\tint query( int node, int l, int r, int ql, int qr ) {",
                  "\t\t\tif( ql > qr ) return 0;",
                  "\t\t\telse if( l == ql && r == qr ) return tree[node];",
                  "\t\t\telse { ",
                      "\t\t\t\tint m = (l+r)/2, le = (node<<1), ri = le+1; shift(node,l,r);",
                      "\t\t\t\treturn func(query(le,l,m,ql,min(qr,m)),query(ri,m+1,r,max(m+1,ql),qr));", 
                  "\t\t\t}",
              "\t\t}",
              "\t\tvoid update( int node, int l, int r, int ul, int ur, int inc_by ) {",
                  "\t\t\tif( ul > ur ) return;",
                  "\t\t\telse if( l == ul && r == ur ) upd_lazy(node,l,r,inc_by); ",
                  "\t\t\telse {",
                      "\t\t\t\tshift(node,l,r); int m = (l+r)/2, le = (node<<1), ri = le+1;",
                      "\t\t\t\tupdate(le,l,m,ul,min(m,ur),inc_by); update(ri,m+1,r,max(ul,m+1),ur,inc_by);",
                      "\t\t\t\ttree[node] = func(tree[le],tree[ri]);",
                  "\t\t\t}",
              "\t\t}",
              "\t\tint query(int l, int r) { return query(1,0,n-1,l,r); }", 
              "\t\tvoid update( int l, int r, int inc_by ) { update(1,0,n-1,l,r,inc_by); }",
      "};"
    ],  
    "description": "Lazy Version Of Segment Tree"
  },
  "Scan size and input a vector" : {
    "prefix": "start",
    "body": "int n; cin>>n; vi v(n,0); FOR(i,0,n) cin>>v[i];",
    "description": "Scan size and input a vector (Stater code inside main())"
  },
  "Scan number of queries and process in loop" : {
    "prefix": "query",
    "body": [
      "int q; cin>>q;",
      "FOR(i,0,q) {",
      "\t$1",
      "}"
    ],
    "description": "Scan number of queries and process in loop"
  },
  "Scan size and no. of queries and process": {
    "prefix": "start",
    "body": [
      "int n,q; cin>>n>>q; vi v(n,0); FOR(i,0,n) cin>>v[i];",
      "$1",
      "FOR(i,0,q) {",
      "\t$2",
      "}"
    ]
  },
  "Convex Hull Trick Dynamic Version" : {
      "prefix": "cht",
      "body": [
        "struct Line {",
          "\tmutable li k, m, p;",
          "\tbool operator<(const Line& o) const { return k < o.k; }",
          "\tbool operator<(li x) const { return p < x; }",
        "};",
        "",
        "struct LineContainer : multiset<Line, less<>> {",
          "\t// (for doubles, use inf = 1/.0, div(a,b) = a/b)",
          "\tconst li inf = LLONG_MAX;",
          "\tli div(li a, li b) { // floored division",
            "\t\treturn a / b - ((a ^ b) < 0 && a % b); }",
          "\tbool isect(iterator x, iterator y) {",
            "\t\tif (y == end()) { x->p = inf; return false; }",
            "\t\tif (x->k == y->k) x->p = x->m > y->m ? inf : -inf;",
            "\t\telse x->p = div(y->m - x->m, x->k - y->k);",
            "\t\treturn x->p >= y->p;",
          "\t}",
          "\tvoid add(li k, li m) {",
            "\t\tauto z = insert({k, m, 0}), y = z++, x = y;",
            "\t\twhile (isect(y, z)) z = erase(z);",
            "\t\tif (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
            "\t\twhile ((y = x) != begin() && (--x)->p >= y->p)",
              "\t\t\tisect(x, erase(y));",
          "\t}",
          "\tli query(li x) {",
            "\t\tassert(!empty());",
            "\t\tauto l = *lower_bound(x);",
            "\t\treturn l.k * x + l.m;",
          "\t}",
        "};"
      ],
      "description": "Fully Dynamic Convex Hull for finding max value of kx+m from a set of lines and set of queries."
  },
  "Convex Hull Trick Sorted Slopes" : {
    "prefix": "cht",
    "body": [
        "struct LineContainer_sorted {",
          "\tint pos; vi M, B; // y = M[i]x+B[i]",
          "\tLineContainer_sorted() { pos = 0; }",
          "\tbool is_bad() {" ,
              "\t\tint l = M.size()-1;",
              //"\t\treturn (B[l-2]-B[l])*(M[l-1]-M[l-2]) <= (B[l-2]-B[l-1])*(M[l]-M[l-2]);",
              "\t\treturn (B[l-2]-B[l])*1.0/(M[l]-M[l-2])*1.0 <= (B[l-2]-B[l-1])*1.0/(M[l-1]-M[l-2])*1.0;",
          "\t}",
          "\tvoid add( int slope, int intercept_y ) {",
              "\t\tM.push_back(slope); B.push_back(intercept_y);",
              "\t\twhile( M.size() >= 3 && is_bad() ) M.erase(M.end()-2), B.erase(B.end()-2);",
          "\t}",
          "\tint query_non_dec_x( int x_val ) {",
              "\t\tint M_sz = M.size();",
              "\t\tif( pos >= M_sz ) pos = M_sz-1;",
              "\t\twhile( pos < M_sz-1 && M[pos]*x_val+B[pos] > M[pos+1]*x_val+B[pos+1] ) pos++;",
              "\t\treturn M[pos]*x_val+B[pos];",
          "\t}",
          "\tint bin_search_ans( int x_val ) {",
              "\t\tint M_sz = M.size(), l = 0, r = M_sz;",
              "\t\twhile( l != r ) {",
                 "\t\t\tint m = (l+r)/2;",
                  "\t\t\tif( m+1 < M_sz && x_val*(M[m+1]-M[m]) >= B[m]-B[m+1] ) l = m+1;",
                  "\t\t\telse r = m;",
              "\t\t}",
              "\t\treturn M[l]*x_val+B[l];",
          "\t}",
      "};"
    ],
    "description": "Convex Hull Trick when slopes are in sorted order"
  },
  "Union Find Disjoint Set": {
    "prefix": "ufds",
    "body": [
      "class UF {",
      "\tprivate :",
      "\t\tint N; vector <int> r, p;",
      "\tpublic :",
      "\t\tUF( int n ) {",
      "\t\t\tr.assign(n,0); p.assign(n,-1); for( int i = 0; i < n; i++ ) p[i] = i; N = n;",
      "\t\t}",
      "\t\tbool issame( int i, int j ) {",
      "\t\t\treturn findset(i) == findset(j);",
      "\t\t}",
      "\t\tint findset( int i ) {",
      "\t\t\treturn (p[i] == i) ? i : (p[i] = findset(p[i]));",
      "\t\t}",
      "\t\tvoid join( int i, int j ) {",
      "\t\t\tint x = findset(i), y = findset(j);",
      "\t\t\tif( r[x] < r[y] ) {",
      "\t\t\t\tp[x] = y;",
      "\t\t\t} else {",
      "\t\t\t\tp[y] = x; if( r[x] == r[y] ) r[x]++;",
      "\t\t\t}",
      "\t\t}",
      "};"
    ],
    "description": "UFDS starting code!"
  },
  "Starting template": {
    "prefix": "lol",
    "body": [
      "/*",
      "** Vishal Raj Roy",
      "** Indian Institute of Technology Kharagpur",
      "*/",
      "",
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "",
      "#define posLSB(X) __builtin_ctz(X)",
      "#define num1bit(X) __builtin_popcount(X)",
      "#define numlead0(X) __builtin_clz(X)",
      "#define gcd(X,Y) __gcd(X,Y)",
      "#define pb push_back",
      "#define eb emplace_back",
      "#define mp make_pair",
      "#define mt make_tuple",
      "#define lb lower_bound",
      "#define ub upper_bound",
      "#define bs binary_search",
      "#define ifpresent(CON,VAL) (CON.find(VAL) != CON.end())",
      "#define all(x) x.begin(),x.end()",
      "#define at(X,N) get<N>(X)",
      "#define ins insert",
      "#define xx first",
      "#define yy second",
      "#define sz(x) ((int)x.size())",
      "#define len(x) ((int)x.length())",
      "#define count_ones __builtin_popcountl",
      "#define nl cout<<\"\\n\";",
      "#define name(X) (#X)",
      "#define watch(X) cout << (#X) << \" is \" << (X) << \"\\n\"",
      "#define sqr(x) ((x)*(x))",
      "#define mod(x, m) ((((x) % (m)) + (m)) % (m))",
      "#define max3(a, b, c) max(a, max(b, c))",
      "#define min3(a, b, c) min(a, min(b, c))",
      "#define mem(x,val) memset((x),(val),sizeof(x))",
      "#define rite(X) freopen(X,\"w\",stdout)",
      "#define read(X) freopen(X,\"r\",stdin)",
      "//FOR(i,1,10) gives 1,2,3,....,9 and FOR(i,10,1) gives 9,8,....,1 also FOR(it, end(v), begin(v)) and FOR(it, begin(v), end(v))",
      "#define FOR(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))",
      "#define SEL(X,C) for( auto & X : C )",
      "#define ima INT_MAX",
      "#define imi INT_MIN",
      "#define lma LLONG_MAX",
      "#define lmi LLONG_MIN",
      // http://xorshift.di.unimi.it/splitmix64.c, https://codeforces.com/blog/entry/62393
      "#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }",
      "#define tk(args...) take(args);",
      "",
      "void err(istream_iterator<string> it) {} template<typename T, typename... Args> void err(istream_iterator<string> it, T a, Args... args) { cout << *it << \" = \" << a << \"\\n\"; err(++it, args...);}",
      "void take() {} template<typename T, typename... Args> void take( T & a, Args & ... args ) { cin>>a; take(args...); }",
      "template <class T> struct custom_hash { static uint64_t splitmix64(uint64_t x) { x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31); } T operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM);} T operator()(tuple<uint64_t,uint64_t> x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(get<0>(x) + FIXED_RANDOM)^(splitmix64(get<1>(x) + FIXED_RANDOM) >> 1); } }; // T operator()(pair<uint64_t,uint64_t> x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x.first + FIXED_RANDOM)^(splitmix64(x.second + FIXED_RANDOM) >> 1); } }; ",
      "template <class L, class R> ostream & operator<<(ostream &os, pair<L,R> P) { return os << \"(\" << P.xx << \",\" << P.yy << \")\"; } template<class L, class R> ostream &operator<<(ostream &os, tuple<L,R> P) {return os << \"(\" << get<0>(P) << \",\" << get<1>(P) <<\")\"; } template<class L, class R, class S> ostream &operator<<(ostream &os, tuple<L,R,S> P) { return os << \"(\" << get<0>(P) << \",\" << get<1>(P) << \",\"<< get<2>(P) <<\")\"; } template<class T, class A> ostream &operator<<(ostream& os, vector<T,A> V) {os /*<< name(V)<< \" is \"*/ << \"\\n\"; FOR(i,0,sz(V)) os <<\"  \"<< name(V) << \"[\"<<i<<\"] = \"<< V[i] << \"\\n\"; return os; /*<<\"\\n\";*/ } template<class T, class H, class P, class A> ostream &operator<<(ostream& os, unordered_set<T,H,P,A> S) { os /*name(S) << \" is\"*/<<\" [\"; int i = 0; for(auto ELE : S) {os << ELE; if(i < sz(S)-1 ) os<<\", \"; i++; } return os <<  \"]\"; /*<<\"\\n\"; */ } template<class S, class T, class H, class P, class A> ostream &operator<<(ostream& os, unordered_map<S,T,H,P,A> M) { os /*name(S) << \" is\"*/<<\"\\n\"; for( auto ELE : M ) os <<\"  \"<< name(M) << \"[\"<<ELE.xx<<\"] = \"<< ELE.yy << \"\\n\"; return os; /*<<\"\\n\";*/ } template<class T, class C, class A> ostream &operator<<(ostream& os, multiset<T,C,A> S) { os /*name(S) << \" is\"*/<<\"[\"; int i = 0; for(auto ELE : S) {os << ELE; if(i < sz(S)-1 ) os<<\", \"; i++; } return os <<  \"]\"; /*<<\"\\n\"; */ } template<class T, class R> ostream &operator<<(ostream& os, gp_hash_table<T,null_type,custom_hash<R>> S) { os /*name(S) << \" is\"*/<<\" [\"; int i = 0; for(auto ELE : S) {os << ELE; if(i < sz(S)-1 ) os<<\", \"; i++; } return os <<  \"]\"; /*<<\"\\n\"; */ } template<class T, class Z, class R> ostream &operator<<(ostream& os, gp_hash_table<T,Z,custom_hash<R>> M) { os /*name(S) << \" is\"*/<<\"\\n\"; for( auto ELE : M ) os <<\"  \"<< name(M) << \"[\"<<ELE.xx<<\"] = \"<< ELE.yy << \"\\n\"; return os; /*<<\"\\n\";*/ } template<class T, class R> ostream &operator<<(ostream& os, cc_hash_table<T,null_type,custom_hash<R>> S) { os /*name(S) << \" is\"*/<<\" [\"; int i = 0; for(auto ELE : S) {os << ELE; if(i < sz(S)-1 ) os<<\", \"; i++; } return os <<  \"]\"; /*<<\"\\n\"; */ } template<class T, class Z, class R> ostream &operator<<(ostream& os, cc_hash_table<T,Z,custom_hash<R>> M) { os /*name(S) << \" is\"*/<<\"\\n\"; for( auto ELE : M ) os <<\"  \"<< name(M) << \"[\"<<ELE.xx<<\"] = \"<< ELE.yy << \"\\n\"; return os; /*<<\"\\n\";*/ }",
      "",
      "using st = string; typedef long long int li; typedef pair<int, int> ii; typedef pair<int, ii> iii; typedef tuple<int,int> i2; typedef tuple<int,int,int> i3; typedef vector<int> vi; typedef vector<ii> vii; typedef vector<i2> vi2; typedef vector<i3> vi3; typedef vector<iii> viii; typedef vector<vi> vvi; typedef vector<vvi> vvvi; typedef pair<li, li> ll; typedef pair<li, ll> lll; typedef tuple<li,li> l2; typedef tuple<li,li,li> l3; typedef vector<li> vl; typedef vector<ll> vll; typedef vector<l2> vl2; typedef vector<l3> vl3; typedef vector<lll> vlll; typedef vector<vl> vvl; typedef vector<vvl> vvvl; typedef double db; typedef complex<db> cd; typedef vector<cd> vcd; template <class S> using ve = vector<S>; template <class S> using gr = greater<S>; template <class S> using le = less<S>; template <class S, class T = le<S>> using ms =  multiset<S,T>; template <class S,class T = null_type, class R = size_t> using gp =  gp_hash_table<S,T,custom_hash<R>>; template <class S,class T = null_type, class R = size_t> using cc =  cc_hash_table<S,T,custom_hash<R>>; template <class S,class T, class R = size_t> using um =  unordered_map<S,T,custom_hash<R>>; template <class S, class R = size_t> using us =  unordered_set<S,custom_hash<R>>;",
      "",
      "/*",
      "Welcome to VISHAL RAJ ROY's template library :) the following are here to serve you>>",
      "v_ = vector of '_'                   |    li = long long int      |   For fast insertion/deletion ->", 
      "vl = vector of long                  |    db = double             |               gp<T,S,R>",
      "vi = vector of int                   |    st = string             |   For fast read/write -> cc<T,S,R>", 
      "supported:                           |    ii = pair<int,int>      |   For slow everything ->",
      "1) vi, vvi, vvvi   4) vl, vvl, vvvl  |    iii = pair<int,ii>      |        um<T,S,R> .. R = ( size_t or uint64_t )",
      "2) vii, viii       5) vll, vlll      |    i2 = tuple<int,int>     |        and us<T,R> .. R = ( size_t or uint64_t )",
      "3) vi2, vi3        6) vl2, vl3       |    cdb = complex double    |   supported :",
      "7) vcd                               |    i3 = tuple<int,int,int> |   int/li/pair -> int/li/string/pair...pair<int/li,int/li>",
      "watch(X) is the WATCH DOG, it can print anything and everything, COULD'NT believe? just try it>> ",
      "error(a,b,c,......) takes many parameters and shows you their true face>> ",
      "tk(a,b,c,..) just sucks the variable from the stdin, pure black magic isn't it!>",
      "*/",
      "",
      "const double pi = 2 * acos(0.0);",
      "const int oo = 0x3f3f3f3f; // don't use for long long",
      "const double inf = 1.0/0.0;",
      ""
    ],
    "description": "The starter code for every Competitive Programming Question!"
  },
  "Starting template Normal": {
    "prefix": "norm",
    "body": [
      "/*",
      "** Vishal Raj Roy",
      "** Indian Institute of Technology Kharagpur",
      "*/",
      "",
      "#include <bits/stdc++.h>",
      "",
      "using namespace std;",
      "",
      "#define posLSB(X) __builtin_ctz(X)",
      "#define num1bit(X) __builtin_popcount(X)",
      "#define numlead0(X) __builtin_clz(X)",
      "#define gcd(X,Y) __gcd(X,Y)",
      "#define pb push_back",
      "#define eb emplace_back",
      "#define mp make_pair",
      "#define mt make_tuple",
      "#define lb lower_bound",
      "#define ub upper_bound",
      "#define bs binary_search",
      "#define ifpresent(CON,VAL) (CON.find(VAL) != CON.end())",
      "#define all(x) x.begin(),x.end()",
      "#define at(X,N) get<N>(X)",
      "#define ins insert",
      "#define xx first",
      "#define yy second",
      "#define sz(x) ((int)x.size())",
      "#define len(x) ((int)x.length())",
      "#define count_ones __builtin_popcountl",
      "#define nl cout<<\"\\n\";",
      "#define name(X) (#X)",
      "#define watch(X) cout << (#X) << \" is \" << (X) << \"\\n\"",
      "#define sqr(x) ((x)*(x))",
      "#define mod(x, m) ((((x) % (m)) + (m)) % (m))",
      "#define max3(a, b, c) max(a, max(b, c))",
      "#define min3(a, b, c) min(a, min(b, c))",
      "#define mem(x,val) memset((x),(val),sizeof(x))",
      "#define rite(X) freopen(X,\"w\",stdout)",
      "#define read(X) freopen(X,\"r\",stdin)",
      "//FOR(i,1,10) gives 1,2,3,....,9 and FOR(i,10,1) gives 9,8,....,1 also FOR(it, end(v), begin(v)) and FOR(it, begin(v), end(v))",
      "#define FOR(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))",
      "#define SEL(X,C) for( auto & X : C )",
      "#define ima INT_MAX",
      "#define imi INT_MIN",
      "#define lma LLONG_MAX",
      "#define lmi LLONG_MIN",
      "using st = string; typedef long long int li; typedef pair<int, int> ii; typedef pair<int, ii> iii; typedef tuple<int,int> i2; typedef tuple<int,int,int> i3; typedef vector<int> vi; typedef vector<ii> vii; typedef vector<i2> vi2; typedef vector<i3> vi3; typedef vector<iii> viii; typedef vector<vi> vvi; typedef vector<vvi> vvvi; typedef pair<li, li> ll; typedef pair<li, ll> lll; typedef tuple<li,li> l2; typedef tuple<li,li,li> l3; typedef vector<li> vl; typedef vector<ll> vll; typedef vector<l2> vl2; typedef vector<l3> vl3; typedef vector<lll> vlll; typedef vector<vl> vvl; typedef vector<vvl> vvvl; typedef double db; typedef complex<db> cd; typedef vector<cd> vcd; template <class S> using ve = vector<S>; template <class S> using gr = greater<S>; template <class S> using le = less<S>;",
      "",
      "const double pi = 2 * acos(0.0);",
      "const int oo = 0x3f3f3f3f; // don't use for long long",
      "const double inf = 1.0/0.0;",
      ""
    ],
    "description": "The starter code for every Competitive Programming Question!"
  },
  "Starting template 3": {
    "prefix": "lol3",
    "body": [
      "/*",
      "** Vishal Raj Roy",
      "** Indian Institute of Technology Kharagpur",
      "*/",
      "",
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "",
      "#define posLSB(X) __builtin_ctz(X)",
      "#define num1bit(X) __builtin_popcount(X)",
      "#define numlead0(X) __builtin_clz(X)",
      "#define gcd(X,Y) __gcd(X,Y)",
      "#define pb push_back",
      "#define eb emplace_back",
      "#define mp make_pair",
      "#define mt make_tuple",
      "#define lb lower_bound",
      "#define ub upper_bound",
      "#define bs binary_search",
      // "#define um(A,B) unordered_map <A, B>",
      // "#define us(A) unordered_set <A>",
      // "#define ms(A) multiset <A>",
      "#define ifpresent(CON,VAL) (CON.find(VAL) != CON.end())",
      "#define all(x) x.begin(),x.end()",
      "#define at(X,N) get<N>(X)",
      "#define ins insert",
      "#define xx first",
      "#define yy second",
      "#define sz(x) ((int)x.size())",
      "#define count_ones __builtin_popcountl",
      "#define nl cout<<\"\\n\";",
      // "#define name(X) (#X)",
      "#define watch(X) cout << (#X) << \" is \" << (X) << \"\\n\"",
      // "#define print(X) cout<< name(X) << \" is \"<< X << \\"\\n\";",
      "#define sqr(x) ((x)*(x))",
      "#define mod(x, m) ((((x) % (m)) + (m)) % (m))",
      "#define max3(a, b, c) max(a, max(b, c))",
      "#define min3(a, b, c) min(a, min(b, c))",
      "#define mem(x,val) memset((x),(val),sizeof(x))",
      "#define rite(X) freopen(X,\"w\",stdout)",
      "#define read(X) freopen(X,\"r\",stdin)",
      //"//#define FOR(i,A,B) for( auto (i) = (A); (i) < (B); (i)++ )",
      //"//#define FORN(i,A,B) for( auto (i) = (B); (i) >= (A); (i)-- )",
      "//FOR(i,1,10) gives 1,2,3,....,9 and FOR(i,10,1) gives 9,8,....,1 also FOR(it, end(v), begin(v)) and FOR(it, begin(v), end(v))",
      "#define FOR(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))",
      "#define ima INT_MAX",
      "#define imi INT_MIN",
      "#define lma LLONG_MAX",
      "#define lmi LLONG_MIN",
      // "#define pv(X) name(X); FOR(i,0,sz(X)) { cout<<\"  \"<< (#X) <<\"[\"<<i<<\"] = \"<<X[i]<<\\"\\n\"; }",
      // "#define pvv(X) name(X); FOR(j,0,sz(X)) { cout<<\\"\\n\"; cout<<\"  \"<< (#X) <<\"[\"<<j<<\"]\"<<\\"\\n\"; FOR(i,0,sz(X[j])) { cout<<\"    \"<< (#X) <<\"[\"<<j<<\"][\"<<i<<\"] = \"<<X[j][i]<<\\"\\n\"; } }",
      // "#define pus(X) name(X); for( auto t : X )  cout<<\"  \"<<t; cout<<\\"\\n\";",
      // "#define pum(X) name(X); for( auto t : X ) cout<<\"  \"<< (#X) <<\"[\"<<t.first<<\"] = \"<<t.second<<\\"\\n\";",
      // http://xorshift.di.unimi.it/splitmix64.c, https://codeforces.com/blog/entry/62393
      // "struct custom_hash { static uint64_t splitmix64(uint64_t x) { x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31); } size_t /* <- can make it was uint64_t */ operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM);/* splitmix64(x)^FIXED_RANDOM */}};",
      "#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }",
      "",
      "void err(istream_iterator<string> it) {} template<typename T, typename... Args> void err(istream_iterator<string> it, T a, Args... args) { cout << *it << \" = \" << a << \"\\n\"; err(++it, args...);}",
      "template <class T> struct custom_hash { static uint64_t splitmix64(uint64_t x) { x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31); } T operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM);} T operator()(pair<uint64_t,uint64_t> x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x.first + FIXED_RANDOM)^(splitmix64(x.second + FIXED_RANDOM) >> 1); } };",
      // "struct custom_hash_ll { static uint64_t splitmix64(uint64_t x) { x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31); } uint64_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM);}};",
      // "struct custom_hash_int { static uint64_t splitmix64(uint64_t x) { x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM);} size_t operator()( pair<uint64_t,uint64_t> x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x.first + FIXED_RANDOM)^(splitmix64(x.second + FIXED_RANDOM) >> 1); } };",
      // "struct custom_hash_for_pair { static uint64_t splitmix64(uint64_t x) { x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31); } size_t operator()( pair<uint64_t,uint64_t> x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x.first + FIXED_RANDOM)^(splitmix64(x.second + FIXED_RANDOM) >> 1); } };",
      "template<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) { return os << \"(\" << P.xx << \",\" << P.yy << \")\"; } template<class L, class R> ostream &operator<<(ostream &os, tuple<L,R> P) {return os << \"(\" << get<0>(P) << \",\" << get<1>(P) <<\")\"; } template<class L, class R, class S> ostream &operator<<(ostream &os, tuple<L,R,S> P) { return os << \"(\" << get<0>(P) << \",\" << get<1>(P) << \",\"<< get<2>(P) <<\")\"; } template<class T, class A> ostream &operator<<(ostream& os, vector<T,A> V) {os /*<< name(V)<< \" is \"*/ << \"\\n\"; FOR(i,0,sz(V)) os <<\"  \"<< name(V) << \"[\"<<i<<\"] = \"<< V[i] << \"\\n\"; return os; /*<<\"\\n\";*/ } template<class T, class H, class P, class A> ostream &operator<<(ostream& os, unordered_set<T,H,P,A> S) { os /*name(S) << \" is\"*/<<\" [\"; int i = 0; for(auto ELE : S) {os << ELE; if(i < sz(S)-1 ) os<<\", \"; i++; } return os <<  \"]\"; /*<<\"\\n\"; */ } template<class S, class T, class H, class P, class A> ostream &operator<<(ostream& os, unordered_map<S,T,H,P,A> M) { os /*name(S) << \" is\"*/<<\"\\n\"; for( auto ELE : M ) os <<\"  \"<< name(M) << \"[\"<<ELE.xx<<\"] = \"<< ELE.yy << \"\\n\"; return os; /*<<\"\\n\";*/ } template<class T, class C, class A> ostream &operator<<(ostream& os, multiset<T,C,A> S) { os /*name(S) << \" is\"*/<<\"[\"; int i = 0; for(auto ELE : S) {os << ELE; if(i < sz(S)-1 ) os<<\", \"; i++; } return os <<  \"]\"; /*<<\"\\n\"; */ } ",
      "",
      // "typedef double db;",
      // "typedef string st;",
      // "typedef complex<db> cd;",
      // "typedef vector<cd> vcd;",
      "typedef long long int li;",
      "typedef pair<int, int> ii;",
      "typedef pair<int, ii> iii;",
      "typedef tuple<int,int> i2;",
      "typedef tuple<int,int,int> i3;",
      "typedef vector<int> vi;",
      "typedef vector<ii> vii;",
      "typedef vector<i2> vi2;",
      "typedef vector<i3> vi3;",
      "typedef vector<iii> viii;",
      "typedef vector<vi> vvi;",
      "typedef vector<vvi> vvvi;",
      // "typedef unordered_set<int,custom_hash_int> usi;",
      // "typedef multiset<int> msi;",
      // "typedef multiset<string> mss;",
      "typedef pair<li, li> ll;",
      "typedef pair<li, ll> lll;",
      "typedef tuple<li,li> l2;",
      "typedef tuple<li,li,li> l3;",
      "typedef vector<li> vl;",
      "typedef vector<ll> vll;",
      "typedef vector<l2> vl2;",
      "typedef vector<l3> vl3;",
      "typedef vector<lll> vlll;",
      "typedef vector<vl> vvl;",
      "typedef vector<vvl> vvvl;",
      // "typedef unordered_map<int, usi> usii;",
      // "typedef unordered_map<li, usl> usll;",
      // "typedef multiset<li> msl;",
      // "typedef multiset<string> mss;",
      "using st = string;",
      "template <class S> using ve = vector<S>;",
      "template <class S> using gr = greater<S>;",
      "template <class S> using le = less<S>;",
      "template <class S, class T = le<S>> using ms =  multiset<S,T>;",
      // "// pbds equivalent of unordered_set",
      // "typedef unordered_set<li,custom_hash_int> usl;",
      // "typedef unordered_set<string> uss;",
      // "typedef gp_hash_table<int,null_type,custom_hash_int> gpi;",
      // "typedef gp_hash_table<li,null_type,custom_hash_int> gpl;",
      // "// pbds equivalent of unordered_map",
      "template <class S,class T = null_type, class R = size_t> using gp =  gp_hash_table<S,T,custom_hash<R>>;",
      "template <class S,class T = null_type, class R = size_t> using cc =  cc_hash_table<S,T,custom_hash<R>>;",
      "template <class S,class T, class R = size_t> using um =  unordered_map<S,T,custom_hash<R>>;",
      "template <class S, class R = size_t> using us =  unordered_set<S,custom_hash<R>>;",
      // "typedef unordered_map<string,int> umsi; typedef unordered_map<string,li> umsl;",
      // "typedef gp_hash_table<int,int,custom_hash_int> gpii; typedef cc_hash_table<int,int,custom_hash_int> ccii; typedef unordered_map<int,int,custom_hash_int> umii;",
      // "typedef gp_hash_table<int,li,custom_hash_int> gpil; typedef cc_hash_table<int,li,custom_hash_int> ccil; typedef unordered_map<int,li,custom_hash_int> umil;",
      // "typedef gp_hash_table<li,li,custom_hash_int> gpll; typedef cc_hash_table<li,li,custom_hash_int> ccll; typedef unordered_map<li,li,custom_hash_int> umll;",
      // "typedef gp_hash_table<li,int,custom_hash_int> gpli; typedef cc_hash_table<li,int,custom_hash_int> ccli; typedef unordered_map<li,int,custom_hash_int> umli;",
      // "typedef gp_hash_table<li,string,custom_hash_int> gpls; typedef cc_hash_table<li,string,custom_hash_int> ccls; typedef unordered_map<li,string,custom_hash_int> umls;",
      // "typedef gp_hash_table<int,string,custom_hash_int> gpis; typedef cc_hash_table<int,string,custom_hash_int> ccis; typedef unordered_map<int,string,custom_hash_int> umis;",
      // "typedef gp_hash_table<ii,int,custom_hash_for_pair> gpiii; typedef cc_hash_table<ii,int,custom_hash_for_pair> cciii; typedef unordered_map<ii,int,custom_hash_for_pair> umiii;",
      // "typedef gp_hash_table<ll,li,custom_hash_for_pair> gplll; typedef cc_hash_table<ll,li,custom_hash_for_pair> cclll; typedef unordered_map<ll,li,custom_hash_for_pair> umlll;",
      // "typedef gp_hash_table<ii,li,custom_hash_for_pair> gpiil; typedef cc_hash_table<ii,li,custom_hash_for_pair> cciil; typedef unordered_map<ii,li,custom_hash_for_pair> umiil;",
      // "typedef gp_hash_table<ll,int,custom_hash_for_pair> gplli; typedef cc_hash_table<ll,int,custom_hash_for_pair> cclli; typedef unordered_map<ll,int,custom_hash_for_pair> umlli;",
      "",
      "const double pi = 2 * acos(0.0);",
      "const int oo = 0x3f3f3f3f; // don't use for long long",
      "const double inf = 1.0/0.0;",
      ""
    ],
    "description": "The starter code for every Competitive Programming Question!"
  },
  "int main()": {
    "prefix": "main",
    "body": [
      "int main() {",
      "\tios_base::sync_with_stdio(0);",
      "\t$1",
      "\treturn 0;",
      "}",
      ""
    ],
    "description": "Bring on the int main()!"
  },
  "read" : {
    "prefix": "re",
    "body": "read(\"$1.txt\");",
    "description": "Read input from file"
  },
  "write" : {
    "prefix": "ri",
    "body": "rite(\"$1.txt\");",
    "description": "Write output to file"
  },
  "assign()" : {
    "prefix": "as",
    "body": "assign($1,$2);",
    "description": "Assign size to a vector"
  },
  "watch(X)" : {
    "prefix": "wa",
    "body": "watch($1);",
    "description": "Print the variable"
  },
  "push()" : {
    "prefix": "pu",
    "body": "push($1);",
    "description": "Push into a container"
  },
  "insert()" : {
    "prefix": "in",
    "body": "insert($1);",
    "description": "Insert into a container"
  },
  "ifpresent(con,val)" : {
    "prefix": "ifp",
    "body": "ifpresent($1,$2)",
    "description": "True if value in present in container"
  },
  "dfs" : {
    "prefix": "dfs",
    "body": [
      "void dfs( int u ) {",
      "\tvis[u] = !vis[u];",
      "\tFOR(i,0,sz(alist)) {",
      "\t\tint v = alist[u][i];",
      "\t\tif(!vis[v]) {",
      "\t\t\tdfs(v);$1",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "Code for Depth First Search"
  },
  "Print Binary Tree" : {
    "prefix": "pbt",
    "body": [
      "void pbt( tree & root, int tab = 0, char desig = 'T' ) {",
        "\t//if( desig == 'T' ) name(root);",
      "\tif(!root) return;",
      "\tFOR(i,0,tab)cout<<\" \"; cout<<desig<<\" : \"; cout<<root->v; cout<<\"\\n\";",
      "\tpbt(root->l, tab+2, 'L');",
      "\tpbt(root->r, tab+2, 'R');",
      "}"
    ],
    "description": "Pretty prints the binary tree"
  },
  "Binary Tree" : {
    "prefix": "bt",
    "body": [
      "struct Tree {",
        "\tint v;",
        "\t Tree * l;",
        "\t Tree * r;",
        "\tTree() {}",
        "\tTree( int val ) : v(val), l(NULL), r(NULL) {}",
        "};",
        "typedef Tree * tree;",
        "",
        "void init( tree & root, int val ) {",
          "\troot = new Tree(val);",
        "}"
    ],
    "description": "Basic binary tree template"
  },
  "Initialize Binary Tree" : {
    "prefix": "inbt",
    "body": [
      "void initbt( vi & info, tree & root, int index ) {",
        "\troot = new Tree(info[index]);",
        "\tif( 2*index+1 >= info.size() ) return;",
        "\tint l = info[2*index+1]; if( l != -1 ) initbt(info, root->l, 2*index+1);",
        "\tif( 2*index+2 >= info.size() ) return;",
        "\tint r = info[index*2+2]; if( r != -1 ) initbt(info, root->r, 2*index+2);",
      "}",
      ""
    ],
    "description": "Initialize binary tree using a vector in level wise manner"
  },
  "Trace": {
    "prefix": "tr",
    "body": "trace$1($2);",
    "description": "Calls print functions in #define TRACE"
  },
  "Resize" : {
    "prefix": "res",
    "body": "resize($1);",
    "description": "Resize a vector component"
  },
  "Assign" : {
    "prefix": "ass",
    "body": "assign($1);",
    "description": "Assign/Initialize a vector"
  },
  "Error" : {
    "prefix": "err",
    "body": "error($1,$2);",
    "description": "See the values of the variables"
  },
  // "Print" : {
  //   "prefix": "pr",
  //   "body": "print($1);",
  //   "description": "For printing single varible like tuples and pairs"
  // },
  "High Presicion Random Number Generator1" : {
    "prefix": "rand",
    "body": "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
    "description": "call rng() to generate high precision random number as per https://codeforces.com/blog/entry/61675"
  },
  "High Presicion Random Number Generator2" : {
    "prefix": "rand",
    "body": "mt19937 rng((uint64_t) new char);",
    "description": "call rng() to use the address of a newly allocated heap variable to generate random number as per https://codeforces.com/blog/entry/61675"
  },
  "Manual" : {
    "prefix": "man",
    "body" : [
      "",
      "/*",
      "manRandom -> for random number generation",
      "*/",
      ""
    ],
    "description": "Manual for list of all manual"
  },
  "Random number manual" : {
    "prefix": "manRandom",
    "body": [
      "",
      "/*",
      "As per https://codeforces.com/blog/entry/61587",
      "rand() and random_shuffle() ( <- uses rand() ) has problems due to low value of RAND_MAX",
      "Use mt19937 ( Mersenne Twister based on 2^19937 - 1 ) instead",
      "syntax: ",
      "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "call rng() to generate random numbers",
      "Also use shuffle(A.begin(),A.end(),rng) instead of random_shuffle()",
      "Let your life be full of randomness :)",
      "One last thing: if you want 64-bit random numbers, just use mt19937_64 instead.",
      "*/",
      ""
    ],
    "description": "Manual for random number generation"
  },
  // "SimDor" : {
  //   "prefix": "simdor",
  //   "body": [ "#define sim template < class c #define ris return * this #define dor > debug & operator << #define eni(x) sim > typename \\ enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) { sim > struct rge { c b, e; }; sim > rge<c> range(c i, c j) { return rge<c>{i, j}; } sim > auto dud(c* x) -> decltype(cout << *x, 0); sim > char dud(...); struct debug { ~debug() { cout << \"\\n\"; } eni(!=) cout << boolalpha << i; ris; } eni(==) ris << range(begin(i), end(i)); } sim, class b dor(pair < b, c > d) {   ris << \"(\" << d.first << \", \" << d.second << \")\"; } sim dor(rge<c> d) { *this << \"[\"; for (auto it = d.b; it != d.e; ++it) *this << \", \" + 2 * (it == d.b) << *it; ris << \"]\"; }};", 
  //   "#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \""  
  //   ],
  //   "description": "use as debug() << imie(a) imie(b) imie(c) ..; to print a,b,.. for more see at https://codeforces.com/blog/entry/67830"
  // }
  // "Print Vector" : {
  //   "prefix": "pv",
  //   "body": "name($1); FOR(i,0,sz($1)) { cout<<\"  $1[\"<<i<<\"] = \"<<$1[i]<<\\"\\n\"; }",
  //   "description": "Print the Vector"
  // },
  // "Print Vector of Vector" : {
  //   "prefix": "pvv",
  //   "body": "name($1); FOR(i,0,sz($1)) { cout<<\"  $1[\"<<i<<\"] = \"<<$1[i]<<\\"\\n\"; }",
  //   "description": "Print the Vector"
  // }
}
